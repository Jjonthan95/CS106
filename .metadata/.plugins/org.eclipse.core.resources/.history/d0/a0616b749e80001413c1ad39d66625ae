/** MemoryPanel.java – John K. Estell
 * Implementation of a "memory panel"
 * Created on April 21, 2005, 12:49 PM
 */
package memorygame;


 import java.awt.*;
 import javax.swing.*;
import java.awt.event.*;
import javax.swing.border.*;
import java.util.*;
import java.io.*;
/**
 *
 * @author jestell
 */
public class MemoryPanel extends javax.swing.JPanel implements Serializable {
 /**
	 * 
	 */
	private static final long serialVersionUID = 1L;
	
public final static int X_OFFSET = 5; // upper left (x,y) coordinate for Image
 public final static int Y_OFFSET = 5; //
 public final static int X_INDENT = 5; // right side indent
 public final static int Y_INDENT = 5; // bottom indent
 public int row = 4; // set as variables for future expansion
 public int col = 4; // (pass row,col info with constructor)

 private Image currentImage;
 private int panelWidth;
 private int panelHeight;
 private JLabel[] lbl;
 private int selectCounter = 0;
 private int firstPick, secondPick;
 private String[] match;
 private java.util.List<String> matchList = new ArrayList<String>();
 private javax.swing.Timer displayDelay;
 private boolean ignoreInput = false;
 /** Creates new form MemoryPanel */
 public MemoryPanel() {
 initComponents();
 initPanel();
 }

 private void initPanel() {

 // create list of matched pairs of one-character strings, then
 // shuffle the list
 Character c;
 for ( int i = 0; i < row * col / 2; i++ ) {
 c = new Character( (char) ('A' + i) );
 matchList.add( c.toString() );
 matchList.add( c.toString() );
 }
 Collections.shuffle( matchList );

 // set up corresponding arrays of strings and labels for the display
 match = new String[ row * col ];
 lbl = new JLabel[ row * col ];

 // populate the grid layout with our tiles - the String array keeps
 // the reference to the "hidden" values to be matched; the label will
 // openly display a numeric value, display the hidden value when
 // selected, and disappear if there is a match.
 for ( int i = 0; i < row * col; i++ ) {
 match[i] = matchList.get(i);
 lbl[i] = new JLabel();
 lbl[i].setText( Integer.toString( i + 1 ) );
 lbl[i].setFont( new Font( "SansSerif", Font.BOLD, 24 ) );
 lbl[i].setOpaque( true );
 lbl[i].setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);
 lbl[i].setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
 lbl[i].setForeground( Color.black );
 lbl[i].setBorder( new LineBorder( Color.black ) );  lbl[i].addMouseListener( new MouseAdapter() {
 public void mouseClicked( MouseEvent e ) {
 mouseClickedHandler( e );
 }
 } );
 add( lbl[i] );
 }

 // set up our timer for the amount of time to display the revealed
 // hidden values once the second tile is turned.
 displayDelay = new javax.swing.Timer( 2500, new ActionListener() {
 public void actionPerformed( ActionEvent e ) {
 timerActionPerformed();
 }
 } );
 displayDelay.setRepeats( false );
 }

 public void setImage( Image img ) {
 currentImage = img;
 }

 public void setImage( ImageIcon imgIcon ) {
 currentImage = imgIcon.getImage();
 }

 public void displayImage() {
 repaint();
 }

 public void displayImage( ImageIcon imgIcon ) {
 setImage( imgIcon );
 repaint();
 }

 public void displayImage( Image img ) {
 setImage( img );
 repaint();
 }

 public void paintComponent( Graphics g ) {
 super.paintComponent( g ); // must have this first or else all heck breaks loose...

 // drawImage will scale the Image component to the specified width and height
 int width = this.getWidth() - X_OFFSET - X_INDENT;
 int height = this.getHeight() - Y_OFFSET - Y_INDENT;
 g.drawImage( currentImage, X_OFFSET, Y_OFFSET, width, height, this );
 }

 private void timerActionPerformed() {

 // remove the two tiles if there is a match...
 if ( match[firstPick].equals( match[secondPick] ) ) {
 lbl[firstPick].setBorder( null );
 lbl[secondPick].setBorder( null );
 lbl[firstPick].setOpaque( false );
 lbl[secondPick].setOpaque( false );
 lbl[firstPick].setText( "" );
 lbl[secondPick].setText( "" );
 lbl[firstPick].setEnabled( false );
 lbl[secondPick].setEnabled( false );
 }
 else { // restore the tiles to their numeric value display
 lbl[firstPick].setText( Integer.toString( firstPick + 1 ) );
 lbl[secondPick].setText( Integer.toString( secondPick + 1 ) );
 }
 ignoreInput = false;
 }

 private void mouseClickedHandler( MouseEvent e ) {
 if ( ignoreInput ) // then don't process the mouse event
 return;

 // find the label corresponding to the event
 JLabel l = null;
 int index = -1;
 for ( int i = 0; i < row * col; i++ ) {
 if ( e.getSource() == lbl[i] ) {  l = lbl[i];
 index = i;

 // "removed" tiles are just labels that are transparent
 // without any displayed text, so they can still register
 // events - this will ignore the event if the tile has
 // been "removed".
 if ( !l.isOpaque() )
 return;

 // if here, then we'll "reveal" the hidden value by resetting
 // the text to the hidden character.
 l.setText( match[i] );
 break;
 }
 }

 if ( l == null ) // then the mouse event didn't occur on a label...
 return;

 // determine whether this was the first or second selection...
 selectCounter++;
 if ( selectCounter == 1 ) {
 firstPick = index;
 }
 if (selectCounter == 2 ) {
 if ( firstPick == index ) { // can't select the same tile twice!
 selectCounter--;
 return;
 }

 // reset the selection counter and reveal the tiles...
 selectCounter = 0;
 secondPick = index;
 ignoreInput = true;
 displayDelay.start();
 }

 }

 /** This method is called from within the constructor to
 * initialize the form.
 * WARNING: Do NOT modify this code. The content of this method is
 * always regenerated by the Form Editor.
 */
 private void initComponents() {
 setLayout(new java.awt.GridLayout(4, 4));
 }
} 